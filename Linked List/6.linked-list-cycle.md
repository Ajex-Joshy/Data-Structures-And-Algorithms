# Linked List Cycle

**Problem:**

> Given the head of a linked list, determine if the linked list has a cycle.  
> A cycle occurs when a node‚Äôs `next` pointer points back to a **previous node**.

---

## 1Ô∏è‚É£ Approach 1: Using HashSet

**Idea:**

- Keep track of visited nodes using a **HashSet**.
- If a node appears again ‚Üí there is a cycle.
- If traversal ends at `null` ‚Üí no cycle.

**Steps:**

1. Initialize an empty `Set`.
2. Start from `head` and traverse the linked list.
3. For each node:
   - If the node exists in the `Set` ‚Üí **cycle detected**.
   - Else, add the node to the `Set`.
4. If the end of the list is reached ‚Üí **no cycle**.

**Code (JS):**

```js
var hasCycle = function (head) {
  let visited = new Set();
  let current = head;

  while (current) {
    if (visited.has(current)) {
      return true; // cycle detected
    }
    visited.add(current);
    current = current.next;
  }

  return false; // no cycle
};
```

**Complexity:**

- Time: **O(n)**
- Space: **O(n)**

---

## 2Ô∏è‚É£ Approach 2: Slow and Fast Pointers (Floyd‚Äôs Cycle Detection)

**Idea:**

- Use two pointers:
  - `slow` ‚Üí moves **1 step** at a time
  - `fast` ‚Üí moves **2 steps** at a time
- If there is a cycle, `fast` will eventually **meet `slow`**.
- If `fast` reaches `null` ‚Üí no cycle.

**Code (JS):**

```js
var hasCycle = function (head) {
  let slow = head;
  let fast = head;

  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;

    if (slow === fast) {
      return true; // cycle detected
    }
  }

  return false; // no cycle
};
```

**Complexity:**

- Time: **O(n)**
- Space: **O(1)**

---

## üîπ Summary

| Approach  | Time Complexity | Space Complexity | Notes                                  |
| --------- | --------------- | ---------------- | -------------------------------------- |
| HashSet   | O(n)            | O(n)             | Simple, easy to implement              |
| Slow-Fast | O(n)            | O(1)             | Optimized, standard interview solution |

---

## üß© My Understanding

I learned that **Linked List Cycle detection** can be solved using either **extra memory (HashSet)** or **two pointers (Floyd‚Äôs Algorithm)**.  
The **HashSet** approach is intuitive and stores visited nodes, while the **Slow-Fast pointer** approach is optimized and uses constant space.  
The slow-fast method works because if a cycle exists, the fast pointer eventually **laps** the slow pointer inside the cycle.  
I now understand how to efficiently detect cycles in linked lists and the reasoning behind each approach.
