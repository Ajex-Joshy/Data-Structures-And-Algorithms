### Lets create nodes and linked list in javascript

```js
function node(val) {
  this.val = val;
  this.next = null;
}

function linkedList() {
  this.head = null;
  this.size = 0;
}

const myList = new linkedList();

const node1 = new node(10);
const node2 = new node(20);
const node3 = new node(30);

node1.next = node2;
node2.next = node3;

myList.head = node1;
myList.size = 3;

let current = myList.head;
while (current) {
  console.log(current.val);
  current = current.next;
}
```

### Behind the Scenes of Linked List in JavaScript

Let's break down exactly what happens behind the scenes when designing a linked list in JavaScript:

1. **Calling `node(val)` (Understanding the Constructor and `new` keyword)**

   - When you execute `new node(val)`, JavaScript performs several hidden steps internally:
     1. It creates a brand new, empty object in memory.
     2. It sets that object's internal `[[Prototype]]` property to point to `node.prototype`.
     3. It calls the `node` function, binding `this` to the newly created object.
     4. The code inside the constructor executes — in this case:
        ```js
        this.val = val;
        this.next = null;
        ```
        These assignments create two properties on the object:
        - `val` stores the data (the value you pass when creating the node).
        - `next` stores a reference to the next node (currently `null`).
     5. If the constructor doesn’t return an object explicitly, the newly created object is returned automatically.
   - **In simple terms:**
     - A constructor in JavaScript is just a function meant to be called with `new` to create and initialize new objects.
     - The `this` inside the constructor refers to that newly created object.
   - **Behind the scenes:**
     - Every call to `new node(...)` allocates new memory for that specific node.
     - Each node object is unique, having its own `val` and `next` fields stored on the heap.
     - The prototype chain ensures methods (if any were added to `node.prototype`) are shared, saving memory.
   - **Example of what happens in memory:**
     ```js
     const node1 = new node(10);
     // Memory representation:
     // node1 -> { val: 10, next: null }
     ```
   - This explains how the constructor and `new` work together to create structured objects for your linked list.

2. **Calling `linkedList()`**

   - When you call `new linkedList()`, JavaScript creates a new object for the linked list.
   - This object has:
     - `this.head`: Points to the first node (initially `null`).
     - `this.size`: Tracks the number of nodes (initially `0`).

3. **Creating Nodes**

   - `const node1 = new node(10);` creates a node with value `10`.
   - `const node2 = new node(20);` creates a node with value `20`.
   - `const node3 = new node(30);` creates a node with value `30`.
   - Each node is a separate object in memory, with its own `val` and `next`.

4. **Linking Nodes**

   - `node1.next = node2;` sets the `next` pointer of `node1` to reference `node2`.
   - `node2.next = node3;` sets the `next` pointer of `node2` to reference `node3`.
   - Now, the nodes are linked in memory, forming a chain:
     ```
     node1        node2        node3
     +-----+---+  +-----+---+  +-----+---+
     | 10  | o--->| 20  | o--->| 30  | X |
     +-----+---+  +-----+---+  +-----+---+
     ```
     (Arrows show the `next` references; `X` indicates `null`.)

5. **Connecting to the Linked List**

   - `myList.head = node1;` sets the list's `head` to the first node.
   - `myList.size = 3;` updates the list's size.
   - Now, `myList` can access the entire chain starting from `head`.

6. **Traversing the List**
   - `let current = myList.head; while (current) { ... }` starts at the head node.
   - On each iteration:
     - Access the current node's value (`current.val`).
     - Move the pointer to the next node (`current = current.next`).
   - This continues until `current` becomes `null`.

**ASCII Diagram of Traversal:**

```
myList.head
   |
   v
+-----+---+    +-----+---+    +-----+---+
| 10  | o----->| 20  | o----->| 30  | X |
+-----+---+    +-----+---+    +-----+---+
   ^
   |__ current (moves from node to node during traversal)
```
