# Reversing a Linked List

Reversing a linked list is a fundamental operation in data structures. It involves changing the direction of the pointers so that the last node becomes the head and the first node becomes the tail.

---

## Approach: Iterative

**Idea:**  
Iterate through the list and reverse the `next` pointer of each node.

**Steps:**

1. Initialize three pointers:
   - `prev` as `null`
   - `current` as `head`
   - `next` as `null`
2. Traverse the list:
   - Store `current.next` in `next`.
   - Set `current.next = prev`.
   - Move `prev` to `current`.
   - Move `current` to `next`.
3. After the loop, `prev` will point to the new head of the reversed list.

**Time Complexity:** `O(n)` – one pass through the list.  
**Space Complexity:** `O(1)` – no extra space used.

**Example in JavaScript:**

```javascript
var reverseList = function (head) {
  let prev = null;
  let current = head;
  while (current) {
    let next = current.next;
    current.next = prev;
    prev = current;
    current = next;
  }
  return prev;
};
```

---

## Approach: Recursive

**Idea:**  
Reverse the rest of the list recursively and then fix the current node.

**Steps:**

1. Base case: if `head` is `null` or `head.next` is `null`, return `head`.
2. Recursively reverse the list starting from `head.next`.
3. Set `head.next.next = head` to reverse the current link.
4. Set `head.next = null`.
5. Return the new head.

**Time Complexity:** `O(n)` – each node visited once.  
**Space Complexity:** `O(n)` – due to recursion stack.

**Example in JavaScript:**

```javascript
var reverseList = function (head) {
  if (!head || !head.next) return head;
  let newHead = reverseList(head.next);
  head.next.next = head;
  head.next = null;
  return newHead;
};
```

---

**Summary:**

- Iterative method is space-efficient.
- Recursive method is elegant but uses extra stack space.
- Reversing a linked list is essential for problems like palindrome check, reordering lists, and algorithmic optimizations.
