# Finding the Middle of a Linked List

Finding the middle node of a linked list is a common problem in data structures. There are two main approaches to solve this:

---

## 1. Convert Linked List to Array

**Idea:**  
Since arrays allow direct access by index, we can convert the linked list into an array and then access the middle element using its index.

**Steps:**

1. Traverse the linked list and store all nodes (or their values) in an array.
2. Find the middle index: `middleIndex = Math.floor(array.length / 2)`.
3. Access the middle element using this index.

**Time Complexity:** `O(n)` – one pass to convert the list to an array.  
**Space Complexity:** `O(n)` – for storing nodes in an array.

**Example in JavaScript:**

```javascript
var middleNode = function (head) {
  let nodes = [];
  let current = head;
  while (current) {
    nodes.push(current);
    current = current.next;
  }
  return nodes[Math.floor(nodes.length / 2)];
};
```

---

## 2. Slow and Fast Pointers (Tortoise and Hare)

**Idea:**  
Use two pointers moving at different speeds:

- **Slow pointer** moves one step at a time.
- **Fast pointer** moves two steps at a time.

When the fast pointer reaches the end, the slow pointer will be at the middle.

**Steps:**

1. Initialize `slow` and `fast` pointers to the head of the list.
2. Move `slow` by 1 node and `fast` by 2 nodes in each iteration.
3. Stop when `fast` reaches the end (`fast === null` or `fast.next === null`). Two handle cases of odd and even length. dry run the loop to understand it better
4. `slow` now points to the middle node.

**Time Complexity:** `O(n)` – single pass through the list.  
**Space Complexity:** `O(1)` – no extra space needed.

**Example in JavaScript:**

```javascript
var middleNode = function (head) {
  let slow = head;
  let fast = head;
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
  }
  return slow;
};
```

**Advantages:**

- Efficient in both time and space.
- Does not require additional memory like the array approach.
